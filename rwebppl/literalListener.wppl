// SET PARAMETERS //
/////////////////////////////////////////////
var granularity = 30
var threshold = 0.9
var utterances = ["A", "C", "If A, C", "If C, A",
"not A", "not C",
"If A, not C",
"If not A, C",
"If not A, not C",
"If C, not A",
"If not C, A",
"If not C, not A"//,
// ""
]

var alpha = 5 // speaker optimality
var beta0 = 0.5 // speaker utility factor probs
var beta1 = 0.5 // speaker utility factor bayes nets

// var goal='causalNet'
var goal = 'jointP'
// var goal = 'mix'
/////////////////////////////////////////////
display('granularity is set to: ' + granularity)

//Helpers
var roundTo3 = function(x){
  return Math.round(x*1000)/1000
}

var midBins = map(function(x) {roundTo3(x/granularity +
                                        1/(2*granularity))},
                  _.range(0,granularity))

var DiscreteBeta = function(a, b, exclude){
  Infer({model: function(){
    categorical({
      vs:remove(exclude, midBins),
      ps:map(function(x){
        // var xi = x >= 1 ? 0.99 : x == 0 ? 0.01 : x
        Math.exp(Beta({a, b}).score(x))
      }, remove(exclude, midBins))
    })
  }})
}

var buildTable = function(probs, bn){
  if(bn == 'A ind. C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[1],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])]
  }else if(bn=='A implies C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[2],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])]
  } else if(bn == 'C implies A'){
    return [probs[0]*probs[1], (1-probs[1]) * probs[0],
           probs[2]*(1-probs[0]), (1-probs[2])*(1-probs[0])]
  }else{
    return -1
  }
}

// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}


// meaning function to interpret the utterances
var meaning = cache(function(utterance, table){
  utterance == "A" ?
    pa(table) > threshold :

  utterance == "C" ?
    pc(table) > threshold :

  utterance == "If A, C" ?
    table[0] > pa(table) * threshold :

  utterance == "If C, A" ?
    table[0] > pc(table) * threshold :

  utterance == "not A" ?
    pna(table) > threshold :

  utterance == "not C" ?
    pnc(table) > threshold :

  utterance == "If A, not C" ?
    table[2] > pa(table) * threshold :

  utterance == "If not A, C" ?
    table[1] > pna(table) * threshold :

  utterance == "If not A, not C" ?
    table[3] > pna(table) * threshold :

  utterance == "If C, not A" ?
    table[1] > pc(table) * threshold :

  utterance == "If not C, A" ?
    table[2] > pnc(table) * threshold :

  utterance == "If not C, not A" ?
      table[3] > pnc(table) * threshold :

  utterance == "" ?
    true :
  -1
})

//PRIORS
var networkPrior = function() {
  var net = uniformDraw(["A implies C",
                         "C implies A",
                         "A ind. C"])
  return net
 }

var probsPrior = function(network){
  // [p(a), p(c)] or [p(a), p(c|a), p(c|not a)]
  var pcond =  sample(DiscreteBeta(1,1,''))
  var probs = [sample(DiscreteBeta(1,1,'')), pcond]

  if(network == 'A implies C' || network == 'C implies A'){
    return probs.concat(sample(DiscreteBeta(1,1, pcond)))
  }else{
    return probs
  }
}

var statePrior = cache(function(){
  return Infer({method:'enumerate', model:function(){
    var network = networkPrior();
    var probs = probsPrior(network);
    var table = buildTable(probs, network)
    return {'causalNet': network, 'jointP': table}
  }
  })
})

// MODEL
// LITERAL LISTENER
var literalListener = cache(function(utterance, goal){
  Infer({method:'enumerate',model: function(){
           var state = sample(statePrior())
           condition(meaning(utterance, state['jointP']))
           return state
           if(llreturn == 'causalNet'){return state['causalNet']}
           else{return state['jointP']}
  }})
})

// var utterance = "A"
// var utterance = "C"
// var utterance = "If A, C"
// var utterance = "If C, A"
// var utterance = "not A"
// var utterance = "not C"
// var utterance = "If A, not C"
// var utterance = "If not A, C"
// var utterance = "If not A, not C"
// var utterance = "If C, not A"
// var utterance = "If not C, A"
var utterance = "If not C, not A"

display(utterance)
var literalListener = literalListener(utterance, goal)
literalListener