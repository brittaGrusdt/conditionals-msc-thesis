// SET PARAMETERS //
/////////////////////////////////////////////
var granularity = 20
var threshold = 0.9
var utterances = ["A", "C", "If A, C", "If C, A",
"not A", "not C",
"If A, not C",
"If not A, C",
"If not A, not C",
"If C, not A",
"If not C, A",
"If not C, not A"//,
// ""
]

var alpha = 5 // speaker optimality
var beta0 = 0.5 // speaker utility factor probs
var beta1 = 0.5 // speaker utility factor bayes nets

// var goal='causalNet'
var goal = 'jointP'
// var goal = 'mix'
/////////////////////////////////////////////
display('granularity is set to: ' + granularity)

//Helpers
var roundTo3 = function(x){
  return Math.round(x*1000)/1000
}

var midBins = map(function(x) {roundTo3(x/granularity +
                                        1/(2*granularity))},
                  _.range(0,granularity))

var DiscreteBeta = function(a, b, exclude){
  Infer({model: function(){
    categorical({
      vs:remove(exclude, midBins),
      ps:map(function(x){
        // var xi = x >= 1 ? 0.99 : x == 0 ? 0.01 : x
        Math.exp(Beta({a, b}).score(x))
      }, remove(exclude, midBins))
    })
  }})
}

var buildTable = function(probs, bn){
  if(bn == 'A ind. C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[1],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])]
  }else if(bn=='A implies C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[2],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])]
  } else if(bn == 'C implies A'){
    return [probs[0]*probs[1], (1-probs[1]) * probs[0],
           probs[2]*(1-probs[0]), (1-probs[2])*(1-probs[0])]
  }else{
    return -1
  }
}

// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}


// meaning function to interpret the utterances
var meaning = cache(function(utterance, table){
  utterance == "A" ?
    pa(table) > threshold :

  utterance == "C" ?
    pc(table) > threshold :

  utterance == "If A, C" ?
    table[0] > pa(table) * threshold :

  utterance == "If C, A" ?
    table[0] > pc(table) * threshold :

  utterance == "not A" ?
    pna(table) > threshold :

  utterance == "not C" ?
    pnc(table) > threshold :

  utterance == "If A, not C" ?
    table[2] > pa(table) * threshold :

  utterance == "If not A, C" ?
    table[1] > pna(table) * threshold :

  utterance == "If not A, not C" ?
    table[3] > pna(table) * threshold :

  utterance == "If C, not A" ?
    table[1] > pc(table) * threshold :

  utterance == "If not C, A" ?
    table[2] > pnc(table) * threshold :

  utterance == "If not C, not A" ?
      table[3] > pnc(table) * threshold :

  utterance == "" ?
    true :
  -1
})

//PRIORS
var networkPrior = function() {
  var net = categorical({vs: ["A implies C",
                              "C implies A",
                              "A ind. C"],
			ps: [0.01,0.01,0.98]})
  return net
 }

var probsPrior = function(network){
  // [p(a), p(c)] or [p(a), p(c|a), p(c|not a)]
  var pcond =  sample(DiscreteBeta(1,1,''))
  var probs = [sample(DiscreteBeta(1,1,'')), pcond]

  if(network == 'A implies C' || network == 'C implies A'){
    return probs.concat(sample(DiscreteBeta(1,1, pcond)))
  }else{
    return probs
  }
}

var statePrior = cache(function(){
  return Infer({method:'enumerate', model:function(){
    var network = networkPrior();
    var probs = probsPrior(network);
    var table = buildTable(probs, network)
    return {'causalNet': network, 'jointP': table}
  }
  })
})

// MODEL
// LITERAL LISTENER
var literalListener = cache(function(utterance, llreturn){
  Infer({method:'enumerate',model: function(){
           var state = sample(statePrior())
           condition(meaning(utterance, state['jointP']))
           if(llreturn == 'causalNet'){return state['causalNet']}
           else{return state['jointP']}
  }})
})

// PRAGMATIC SPEAKER
// KL-divergence
var KL = function(speaker_probability, listener_probability){
  sum(map(function(cell) {
    if(speaker_probability[cell] == 0 || listener_probability==0){
      0
    }else{
    speaker_probability[cell] *
       Math.log(speaker_probability[cell] / listener_probability[cell])
    }}, _.range(4)))
}

var speakerBNandP = cache(function(state){
  return Infer({method:'enumerate',
                  model: function(){
                    var utterance = uniformDraw(utterances)
                    var LLprob = sample(literalListener(utterance, 'jointP'))
                    var KLdiv = - KL(state['jointP'], LLprob)
                    var LLbn = literalListener(utterance, 'causalNet')
                    factor(alpha*(beta0 * (KLdiv) +
                                  beta1 * LLbn.score(state['causalNet'])))
                    return utterance
                }
               })
})

var speakerBN = cache(function(state){
  return Infer({method:'enumerate',
                  model: function(){
                   var utterance = uniformDraw(utterances)
                   var LLbn = literalListener(utterance, 'causalNet')
                   factor(alpha*LLbn.score(state))
                   return utterance
                  }
                })
})

var speakerP = cache(function(state){
  return Infer({method:'enumerate',
                  model: function(){
                    var utterance = uniformDraw(utterances)
                    var LLprob = sample(literalListener(utterance, 'jointP'))
                    var KLdiv = - KL(state, LLprob)
                    factor(alpha*KLdiv)
                    return utterance
                  }
                 })
})
var speaker = cache(function(state, goal) {
    if(goal=='mix'){
     if(beta0==0 || beta1==0){
       error('beta0 and beta1 cannot be 0 for goal: mix')
     }
     return speakerBNandP(state)
    } else if (goal=='causalNet'){
      return speakerBN(state)
    } else if (goal=='jointP'){
      return speakerP(state)
    }
})
// PRAGMATIC LISTENER
var listener = function(utterance, goal){
  if(goal=='mix'){
//   Infer({method:'rejection', samples:10000, model:function(){
      return Infer({method:'MCMC',
             lag: 1, burn:100, samples:500, model: function(){
                var state = sample(statePrior);
                observe(speaker(state, goal),utterance)
                return state
                }
            })
  }else{
    return Infer({method:'MCMC',
           lag: 1, burn:100, samples:1000, model:function(){
//     Infer({method:'enumerate', model: function(){
      var state = sample(statePrior());
      observe(speaker(state[goal], goal),utterance)
      return {'jointP': state['jointP'], 'causalNet': state['causalNet']}
    }})
  }
}

var pragListener = listener("If A, C", goal)
pragListener