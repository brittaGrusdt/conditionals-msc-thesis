// Samples for graphs
var t = 0.95
var f = 0.05
var m = 0.5
var l = 0.7
var ul = 0.3
var zero = 0.0001
var one = 0.9999

// 1. samples for independent graphs
// samples: P(A), P(C)
var independentProbs = [[t, t], [t, f], [t, m], [t, l], [t, ul],
                        [f, t], [f, f], [f, m], [m, l], [m, ul],
                        [m, t], [m, f], [m, m], [m, l], [m, ul]]

// 2. samples for dependent graphs
// samples: P(A),P(C|A),P(C|not A)
var equivalentProbs = [[f, zero, one],[ul, zero, one], [m, zero, one],
                       [l, zero, one], [t, zero, one],
                       [f, one, zero],[ul, one, zero], [m, one, zero],
                       [l, one, zero], [t, one, zero]]
var conditionedProbsAC = [
  [f, f,zero],  [m, f,zero],  [ul, f,zero], [l, f,zero], [t, f,zero],
  [f, ul,zero], [m, ul,zero], [ul, ul,zero], [l, ul,zero], [t, ul,zero],
  [f, m, zero], [m, m, zero], [ul, m, zero],  [l, m, zero],  [t, m, zero],
  [f, l, zero], [m, l,zero], [ul, l, zero], [l, l, zero], [t, l, zero],
  [f, t, zero], [m, t,zero], [ul, t, zero], [l, t, zero], [t, t, zero]]
var conditionedProbsANC = [
  [f, 1-f, one],  [m, 1-f, one],  [ul, 1-f, one], [l, 1-f, one], [t, 1-f, one],
  [f, 1-ul, one], [m, 1-ul, one], [ul, 1-ul, one], [l, 1-ul, one], [t, 1-ul, one],
  [f, 1-m, one], [m, 1-m, one], [ul, 1-m, one],  [l, 1-m, one],  [t, 1-m, one],
  [f, 1-l, one], [m, 1-l, one], [ul, 1-l, one], [l, 1-l, one], [t, 1-l, one],
  [f, 1-t, one], [m, 1-t, one], [ul, 1-t, one], [l, 1-t, one], [t, 1-t, one]
]
// A->C
//P(C|A)<P(C|not A)
var dependentProbs = [[f, ul,f],[ul, ul,f], [m, ul,f], [l, ul,f], [t, ul,f],

                      [f, m,ul],[ul, m,ul],[m, m,ul],[l, m,ul],[t, m,ul],
                      [f, m,f], [ul, m,f], [m, m,f], [l, m,f], [t, m,f],

                      [f, l,m], [ul, l,m], [m, l,m], [l, l,m], [t, l,m],
                      [f, l,ul], [ul, l,ul], [m, l,ul], [l, l,ul], [t, l,ul],
                      [f, l,f], [ul, l,f], [m, l,f], [l, l,f], [t, l,f],

                      [f, t,l], [ul, t,l], [m, t,l], [l, t,l], [t, t,l],
                      [f, t,m], [ul, t,m], [m, t,m], [l, t,m], [t, t,m],
                      [f, t,ul], [ul, t,ul], [m, t,ul], [l, t,ul], [t, t,ul],
                      [f, t,f], [ul, t,f], [m, t,f], [l, t,f], [t, t,f]]

// A -> not C
var dependentNegProbs = [[f, f,ul],[ul, f,ul],[m, f,ul],[l, f,ul],[t, f,ul],
                         [f, f,m], [ul, f,m], [m, f,m], [l, f,m], [t, f,m],
                         [f, f,l], [ul, f,l], [m, f,l], [l, f,l], [t, f,l],
                         [f, f,t], [ul, f,t], [m, f,t], [l, f,t], [t, f,t],

                         [f, ul,m], [ul, ul,m], [m, ul,m], [l, ul,m], [t, ul,m],
                         [f, ul,l], [ul, ul,l], [m, ul,l], [l, ul,l], [t, ul,l],
                         [f, ul,t], [ul, ul,t], [m, ul,t], [l, ul,t], [t, ul,t],

                         [f, m,l], [ul, m,l], [m, m,l], [l, m,l], [t, m,l],
                         [f, m,t], [ul, m,t], [m, m,t], [l, m,t], [t, m,t],

                         [f, l,t], [ul, l,t], [m, l,t], [l, l,t], [t, l,t]]


////////////  SET PARAMETERS  /////////////////
var biasFactor = 20

var speakerOptimality = 5
var threshold = 0.9
var threshold_likely = 0.5

var utterances = ["A", "C", "If A, C", "If C, A", "not A", "not C", "If A, not C",
                  "If not A, C", "If not A, not C", "If C, not A", "If not C, A",
                  "If not C, not A",
                  "A and C", "A but not C", "C but not A", "neither A nor C", "",
//                   "A exor C", "Either both or none",
                  "A or C", "A or not C", "not A or C", "not A or not C"]
var independentNets = ["A ind. C"]
var dependentNets = ["A condition for C", "A,C dependent", "A,-C dependent",
                     "A,C equivalent", "A condition for not C"]
var causalNets = independentNets.concat(dependentNets)
/////////////////////////////////////////////
var buildTable = function(probs, cn){

  var table = cn=='A ind. C' ?
        [probs[0]*probs[1], (1-probs[0])*probs[1],
         probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])] :

        [probs[0]*probs[1], (1-probs[0])*probs[2],
         probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])]

  return table
}

// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}
var pCgivenNA = function(x){return x[1]/pna(x)}

var utteranceProbs = cache(function(utterance, table){
  var p = utterance == "A" ? pa(table) :
  utterance == "C" ? pc(table) :
  utterance == "If A, C" ? table[0]/pa(table) :
  utterance == "If C, A" ? table[0]/pc(table) :
  utterance == "not A" ? pna(table) :
  utterance == "not C" ? pnc(table) :
  utterance == "If A, not C" ? table[2]/pa(table) :
  utterance == "If not A, C" ? table[1] / pna(table) :
  utterance == "If not A, not C" ? table[3] / pna(table) :
  utterance == "If C, not A" ? table[1] / pc(table) :
  utterance == "If not C, A" ? table[2] / pnc(table):
  utterance == "If not C, not A" ? table[3] / pnc(table) :
  utterance == "Either both or none" ? table[0]+table[3] :
  utterance == "likely A" ? table[0] + table[2] :
  utterance == "likely C" ? table[0] + table[1] :
  utterance == "A exor C" ? table[1] + table[2] :
  utterance == "A and C" ? table[0] :
  utterance == "neither A nor C" ? table[3] :
  utterance == "A but not C" ? table[2] :
  utterance == "C but not A" ? table[1] :
  utterance == "A or C" ? 1-table[3] :
  utterance == "A or not C" ? 1-table[1] :
  utterance == "not A or C" ? 1-table[2] :
  utterance =="not A or not C" ? 1-table[0] :
  utterance == "" ?
    true : error("unknown utterance " + utterance)
  return p
})

var meaning = cache(function(utterance, table){
 var p = utteranceProbs(utterance, table)
 var holds = utterance.includes('likely') ?
     (p > threshold_likely) : p > threshold


return holds
})

//PRIORS
var networkPrior = function(isDependent) {
//   var net = isDependent ? uniformDraw(dependentNets) :
//   uniformDraw(independentNets)
  var net = uniformDraw(causalNets)
  return net
}
var bayesNetPrior = cache(function(bias){
  return Infer({method:'enumerate', model:function(){
    var dependent = flip()
    var cn = networkPrior(dependent)
    var probs = cn=='A ind. C' ? uniformDraw(independentProbs) :
    cn=="A condition for C" ? uniformDraw(conditionedProbsAC) :
    cn=="A condition for not C" ? uniformDraw(conditionedProbsANC) :
    cn=="A,C dependent" ? uniformDraw(dependentProbs) :
    cn=="A,C equivalent" ? uniformDraw(equivalentProbs) :
    cn=='A,-C dependent' ? uniformDraw(dependentNegProbs) :
     error('no probs defined for cn: ' + cn)
    var table = buildTable(probs, cn)

    if(bias){
      var vote = bias=='douven1' ? (pc(table)>=t ? -Math.log(1/biasFactor) : 0) :
      bias=='pizza' ? (pc(table)>=threshold ? -Math.log(1/biasFactor) : 0) :
      bias=='lawn-non-negotiable' ?
          (probs[2]<=f ? -Math.log(1/biasFactor) : 0) :
      bias=='lawn-negotiable' ?
          (probs[2]>=m ? -Math.log(1/biasFactor) : 0) :
      bias=='douven2' ? (probs[0]>=ul && probs[0]<=m &&
                         (pc(table)>=m && pc(table)<=l)
                          ? -Math.log(1/biasFactor) : 0) :
      bias=='douven3' ? (pc(table)<=m ? -Math.log(1/biasFactor) : 0) : 0
      factor(vote)
    }
    return {'cn': cn, 'jointP': table}
  }})
})

// MODEL
var literalListener = cache(function(utterance, query, cn, bias){
  Infer({method:'enumerate',model: function(){
    var bn = sample(bayesNetPrior(bias))
    // condition(bn.cn==cn)
    condition(meaning(utterance, bn['jointP']))
    if(query == 'cn'){return bn['cn']}
    else if(query == 'jointP'){return bn['jointP']}
    else{return bn}
  }})
})

var KL = function(approx_probability_input, true_probability_input){
  var true_probability = _.isArray(true_probability_input) ?
     true_probability_input :
     [true_probability_input, 1 - true_probability_input]
  var approx_probability = _.isArray(approx_probability_input) ?
     approx_probability_input :
     [approx_probability_input, 1 - approx_probability_input]
  sum(map(function(cell) {
    if(true_probability[cell] == 0){0}
    else if(approx_probability[cell]==0){error('undefined KL')}
    else{
      true_probability[cell] *
       Math.log(true_probability[cell] / approx_probability[cell])
    }}, _.range(true_probability.length)))
}

var get_LL_avg = cache(function(utterance, cn, bias) {
  var LL = literalListener(utterance, 'jointP', cn, bias)
  var LL_avg = map(function(cell){ sum(map(function(LLtable) {
    Math.exp(LL.score(LLtable)) * LLtable[cell]
  },
                   LL.support()))}, _.range(4))
  return(LL_avg)
})

var get_EU_avg = function(utterance, table, qud, cn, bias) {
  var LL_avg = get_LL_avg(utterance, cn, bias)
  var utility = qud=='C' ? -KL(pc(table), pc(LL_avg)) :
                qud=='A' ? -KL(pa(table), pa(LL_avg)) :
                -KL(table, LL_avg)
  return utility

}

var speaker = cache(function(table, qud, cn, bias){
  return Infer({method:'enumerate', model: function(){
    var utterance = uniformDraw(utterances)
    var utility = get_EU_avg(utterance, table, qud, cn, bias)
    factor(speakerOptimality * utility)
    return utterance
  }
 })
})

var listener = function(utterance, qud, bias){
   return Infer({method:'enumerate', model:function(){
      var bn = sample(bayesNetPrior(bias))
      observe(speaker(bn['jointP'], qud, bn.cn, bias),utterance)
      return bn
    }
   })
}

var displayLL = function(utterance, query, cn, bias){
  display('Literal Listener hears: ' + utterance)
  if(query=='jointP'){
    var LL = literalListener(utterance, "jointP", cn, bias)
    print(evs(LL))
  }else if(query=='cn'){
    var LL = literalListener(utterance, 'cn', cn, bias)
    viz(LL)
  }else{error('only marginals supported for visualizing LL')}
}

var displayS = function(utterance, qud, cn, bias){
  qud ? display('qud is: ' + qud) : display('qud is not used')
  var LL = sample(literalListener(utterance, "bn", cn, bias))
  display('speaker p: ' + LL.jointP)
  display('speaker cn: ' + LL.cn)
  viz(speaker(LL.jointP, qud, cn, bias))
}

var displayPL = function(pragListener){
  viz(marginalize(pragListener, function(bn){return{causalNet: bn.cn}}))
  viz(marginalize(pragListener, function(bn){return{causalNets:
    dependentNets.includes(bn.cn) ? 'dependent' : 'independent'}}))
  var listenerProbs = marginalize(pragListener, function(bn){return bn['jointP']})
  // print(evs(listenerProbs))
  display(evs(listenerProbs))
}

var getEVs = function(listener, probFunc){
  var listener_avg = sum(map(function(LLtable) {
    Math.exp(listener.score(LLtable)) * probFunc(LLtable)
  }, listener.support()))
  return listener_avg
}

var evs = function(pragListener){
  return {'C|A': getEVs(pragListener, pCgivenA),
          'A|C': getEVs(pragListener, pAgivenC),
          'C|-A': getEVs(pragListener, pCgivenNA),
          'A|-C': getEVs(pragListener, pAgivenNC),
          'A': getEVs(pragListener, pa),
          'C': getEVs(pragListener, pc)}
}
//PLOTS
// var utterance = "A"
// var utterance = "If A, not C"
// var utterance = "If C, A"
// var utterance = "If A, C"
// var qud = "C"
var qud = ""

// var bias = ""
// var query = "jointP"
// var bias = "pizza"
// var bias = "lawn-negotiable"
// var bias = "lawn-non-negotiable"
// var bias = "douven1"
var utterance = myDF["utterance"][0]
var bias = myDF["bias"][0]

// display('Bayes Net Prior')
// viz.table(bayesNetPrior(bias))
// viz(marginalize(bayesNetPrior(bias), function(bn){bn.cn}))
// viz(marginalize(bayesNetPrior(bias), function(bn){
//   dependentNets.includes(bn.cn) ? 'dependent' : 'independent'}))

// Literal listener
// displayLL(utterance, 'cn', 'A,C dependent', bias)
// displayLL(utterance, 'jointP', 'A,C dependent', bias)
// display('LL_avg for utterance: ' + utterance)
// display(get_LL_avg(utterance, causalNet, bias))

// map(function(utterance){print(utterance + get_LL_avg(utterance, causalNet))},
//     utterances)

// Pragmatic speaker
// var p = [0.677, 0.29, 0.001, 0.032]
// var p = [0.274, 0.159, 0.019, 0.548]
// var p = [0.246, 0.321, 0.014, 0.419]
// var p = [0.048, 0.617, 0.003, 0.332]
// var p = [0.024375,0.365625,0.0006250000000000006,0.609375]
// var p = [0.475,0.025,0.475,0.025]
// var p = [0.475,0.475,0.0025000000000000022,0.04750000000000004]
// var p = [0.475, 0.025, 0.025, 0.475]
// var p = [0.0475, 0.475, 0.0025, 0.475]
// var p = [0.475, 0.475, 0.0475, 0.0025]
// var p = [0.25, 0.475, 0.025, 0.025]
// var p = [0.0475,0.0475, 0.0025, 0.9025]
// display('Pragmatic speakers table: ' + p)
// var x = get_LL_avg('If not C, A', causalNet, bias)
// var y = get_LL_avg('If not A, C', causalNet, bias)
// var z = get_LL_avg('likely A exor C', causalNet, bias)
// print('If not C, A: LL_avg ' + x + ' ; KL: ' + KL(p, x))
// print('If not A, C: LL_avg ' + y + ' ; KL: ' + KL(p, y))
// print('likely A exor C: LL_avg ' + z + ' ; KL: ' + KL(p, z))

// viz(speaker(p, qud, causalNet, bias))

// displayS(utterance, qud, causalNet, bias)

// Pragmatic Listener
display('Pragmatic Listener hears: ' + utterance + ' bias:' + bias)

var pragListener = listener(utterance, qud, bias)
// displayPL(pragListener)
pragListener
