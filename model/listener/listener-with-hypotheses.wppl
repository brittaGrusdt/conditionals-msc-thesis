////////////  SET PARAMETERS  /////////////////

var speakerOptimality = 5
var threshold = 0.9
var threshold_likely = 0.5
// prior biases for biscuits/perfection
var biasFactor = 20


var nsamples = 1500
var ntables = 500

var utterances = ["A", "C", "If A, C", "If C, A", "not A", "not C", "If A, not C",
                  "If not A, C", "If not A, not C", "If C, not A", "If not C, A",
                  "If not C, not A",
                  "A and C", "A but not C", "C but not A", "neither A nor C"]
//                   "A exor C",
//                   "Either both or none",
                  // "likely A", "likely C"]
var independentNets = ["A ind. C"]

var biscuitNetsAC = ["A biscuits C", "A biscuits not C",
                     "not A biscuits C", "not A biscuits not C"]
var biscuitNetsCA = ["C biscuits A", "C biscuits not A",
                     "not C biscuits A", "not C biscuits not A"]
var biscuitNets = biscuitNetsAC.concat(biscuitNetsCA)


var dependentNetsAC = ["A implies C", "A implies not C",
                       "not A implies C", "not A implies not C"]
var dependentNetsCA = ["C implies A", "C implies not A",
                       "not C implies A", "not C implies not A"]
var dependentNets = dependentNetsAC.concat(dependentNetsCA)

var perfectionNetsAC = ["A perfects C", "A perfects not C",
                        "not A perfects C", "not A perfects not C"]
var perfectionNetsCA = ["C perfects A", "C perfects not A",
                        "not C perfects A", "not C perfects not A"]
var perfectionNets = perfectionNetsAC.concat(perfectionNetsCA)

var causalNets = dependentNets.concat(perfectionNets).concat(biscuitNets).
concat(independentNets)



display('ntables for prior is set to: ' + ntables)
display('speaker optimality is set to ' + speakerOptimality)
display("# samples for pragmatic listener: " + nsamples)
display('----------------------------------------')
/////////////////////////////////////////////

var roundTo3 = function(x){
  return Math.round(x*1000)/1000
}

var buildTable = function(probs, cn){
  var table =
    cn=='A ind. C' ?
        [probs[0]*probs[1], (1-probs[0])*probs[1],
         probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])] :

    cn=='A implies C' || cn=="A biscuits C" || cn=="A perfects C" ?
        [probs[0]*probs[1], (1-probs[0])*probs[2],
         probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])] :

    cn=='A implies not C' || cn=="A biscuits not C" || cn=="A perfects not C" ?
        [(1-probs[1]) * probs[0], (1-probs[2]) * (1-probs[0]),
         probs[1] * probs[0]    , probs[2] * (1-probs[0])] :

    cn=='not A implies C' || cn=="not A biscuits C" || cn=="not A perfects C" ?
        [(1-probs[0])*probs[2]    , probs[1] * probs[0],
         (1-probs[0])*(1-probs[2]), (1-probs[1])*probs[0]] :

    cn=='not A implies not C' || cn=="not A biscuits not C" ||
      cn=='not A perfects not C'?
        [(1-probs[2]) * (1-probs[0]), (1-probs[1]) * probs[0],
         probs[2] * (1-probs[0])    , probs[1]*probs[0]] :

    cn=='C implies A' || cn=="C biscuits A" || cn=="C perfects A" ?
        [probs[0]*probs[1]    , (1-probs[1]) * probs[0],
         probs[2]*(1-probs[0]), (1-probs[2])*(1-probs[0])] :

    cn=='C implies not A' || cn=="C biscuits not A" || cn=="C perfects not A" ?
        [(1-probs[1]) * probs[0]   , probs[1] * probs[0],
        (1-probs[2]) * (1-probs[0]), probs[2] * (1-probs[0])] :

    cn=='not C implies A' || cn=="not C biscuits A" || cn=='not C perfects A' ?
        [(1-probs[0])*probs[2], (1-probs[2]) * (1-probs[0]),
         probs[1]*probs[0], (1-probs[1])*probs[0]] :

    cn=='not C implies not A' || cn=="not C biscuits not A" ||
      cn=='not C perfects not A' ?
        [(1-probs[2]) * (1-probs[0]), probs[2] * (1-probs[0]),
         (1-probs[1]) * probs[0], probs[1]*probs[0]] :

    error("probability table cannot be build for cn " + cn)
    return table
}

// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}
var pCgivenNA = function(x){return x[1]/pna(x)}

var utteranceProbs = cache(function(utterance, table){
  var p = utterance == "A" ? pa(table) :
  utterance == "C" ? pc(table) :
  utterance == "If A, C" ? table[0]/pa(table) :
  utterance == "If C, A" ? table[0]/pc(table) :
  utterance == "not A" ? pna(table) :
  utterance == "not C" ? pnc(table) :
  utterance == "If A, not C" ? table[2]/pa(table) :
  utterance == "If not A, C" ? table[1] / pna(table) :
  utterance == "If not A, not C" ? table[3] / pna(table) :
  utterance == "If C, not A" ? table[1] / pc(table) :
  utterance == "If not C, A" ? table[2] / pnc(table):
  utterance == "If not C, not A" ? table[3] / pnc(table) :
  utterance == "Either both or none" ? table[0]+table[3] :
  utterance == "likely A" ? table[0] + table[2] :
  utterance == "likely C" ? table[0] + table[1] :
  utterance == "A exor C" ? table[1] + table[2] :
  utterance == "A and C" ? table[0] :
  utterance == "neither A nor C" ? table[3] :
  utterance == "A but not C" ? table[2] :
  utterance == "C but not A" ? table[1] :
  utterance == "" ?
    true : error("unknown utterance " + utterance)
  return p
})

var meaning = cache(function(utterance, table){
 var p = utteranceProbs(utterance, table)
 var holds = utterance == 'likely A' || utterance == 'likely C' ?
     p > threshold_likely : p > threshold

return holds
})

//PRIORS
// samples: [p(a), p(c|a), p(c|not a)]
var probsPrior = function(cn) {
  Infer({method:'forward', samples: ntables, model:function(){
    var probs =
      cn.includes('biscuits') ? [beta({a:10, b: 1}), beta({a:10, b:1})] :
      cn.includes('perfects') ? [beta({a:10, b: 1}), beta({a:1, b:10})] :
      !cn.includes('ind') ?  [beta({a:10, b: 1}), beta({a:1, b:1})] :
        [beta({a:1, b:1})]

    return [beta({a:1, b: 1})].concat(probs)
    }})
}

var networkPrior = function() {
  var net = uniformDraw(causalNets)
  return net
}

var bayesNetPrior = cache(function(bias){
  return Infer({method:'enumerate', model:function(){
    var causalNet = networkPrior()
    var probs = sample(probsPrior(causalNet))
    var table = buildTable(probs, causalNet)
    if(bias=='biscuits'){
        factor(independentNets.includes(causalNet) ||
          biscuitNets.includes(causalNet) ? -Math.log(1/biasFactor) : 0)

    } else if(bias=='conditional'){
       factor(dependentNets.includes(causalNet) ||
              perfectionNets.includes(causalNet) ? -Math.log(1/biasFactor) : 0)
    }
    return {'cn': causalNet, 'jointP': table}
  }})
})

// MODEL
var literalListener = cache(function(utterance, query){
  Infer({method:'enumerate',model: function(){
    var bn = sample(bayesNetPrior())
    condition(meaning(utterance, bn['jointP']))
    if(query == 'cn'){return bn['cn']}
    else if(query == 'jointP'){return bn['jointP']}
    else{return bn}
  }})
})

var KL = function(speaker_probability_input, listener_probability_input){
  var speaker_probability = _.isArray(speaker_probability_input) ?
     speaker_probability_input :
     [speaker_probability_input, 1 - speaker_probability_input]
  var listener_probability = _.isArray(listener_probability_input) ?
     listener_probability_input :
     [listener_probability_input, 1 - listener_probability_input]
  sum(map(function(cell) {
    if(speaker_probability[cell] == 0 || listener_probability[cell]==0){
      0
    }else{
    speaker_probability[cell] *
       Math.log(speaker_probability[cell] / listener_probability[cell])
    }}, _.range(speaker_probability.length)))
}

var hellingerDistance = function(speaker_probs,listener_probs){
  var speaker_probability = _.isArray(speaker_probs) ?
     speaker_probs :
     [speaker_probs, 1 - speaker_probs]
  var listener_probability = _.isArray(listener_probs) ?
     listener_probs :
     [listener_probs, 1 - listener_probs]

  var hellinger = (1/Math.SQRT2) * Math.sqrt(sum(map(function(i) {
    //sum all the states
    //calculate distance at each state
    var at_state = Math.pow(Math.sqrt(speaker_probability[i]) -
                            Math.sqrt(listener_probability[i]), 2)
    _.isNaN(at_state) ? 0 : at_state
  },_.range(speaker_probability.length))))
  return hellinger
}

var get_LL_avg = cache(function(utterance) {
  var LL = literalListener(utterance, 'jointP')
  var LL_avg = map(function(cell){ sum(map(function(LLtable) {
    Math.exp(LL.score(LLtable)) * LLtable[cell]
  },
                   LL.support()))}, _.range(4))
  return(LL_avg)
})

var get_EU_avg = function(utterance, table, qud) {
  var LL_avg = get_LL_avg(utterance)
  var utility = qud=='C' ? -KL(pc(table), pc(LL_avg)) :
                qud=='A' ? -KL(pa(table), pa(LL_avg)) :
                0
  return utility - KL(table, LL_avg)
  // var utility = qud=='C' ? -KL(pc(table), pc(LL_avg)) :
  //               qud=='A' ? -KL(pa(table), pa(LL_avg)) :
  //               - KL(table, LL_avg)
  // return utility

  // var utility =
  // qud=='C' ? -hellingerDistance(pc(table), pc(LL_avg)) :
  // qud=='A' ? -hellingerDistance(pa(table), pa(LL_avg)) :
  //  - hellingerDistance(table, LL_avg)
  // return utility - hellingerDistance(table, LL_avg)
}

var speaker = cache(function(table, qud){
  return Infer({method:'enumerate', model: function(){
    var utterance = uniformDraw(utterances)
    var utility = get_EU_avg(utterance, table, qud)
    factor(speakerOptimality * utility)
    return utterance
  }
 })
})

var listener = function(utterance, qud, bias){
//   return Infer({method:'MCMC', samples:nsamples, lag:1, burn:100,
//                 callbacks: [editor.MCMCProgress()],  model:function(){
    return Infer({method:'rejection',samples:nsamples, model:function(){
      var bn = sample(bayesNetPrior(bias))
      observe(speaker(bn['jointP'], qud),utterance)
      return bn
    }
   })
}

var summarizeListenerCNs = function(listener){
  marginalize(listener, function(bn){
    dependentNetsAC.includes(bn.cn) || perfectionNetsAC.includes(bn.cn) ||
      biscuitNetsAC.includes(bn.cn) ?
      'C depends on A' :
    dependentNetsCA.includes(bn.cn) || perfectionNetsCA.includes(bn.cn) ||
      biscuitNetsCA.includes(bn.cn) ?
      'A depends on C' :
    independentNets.includes(bn.cn) ?
      'A,C ind.' : error('unknown CausalNet: ' + bn.cn)
   })
}

var displayLL = function(utterance, query){
  display('Literal Listener hears: ' + utterance)
  if(query=='jointP'){
    var LL = literalListener(utterance, "jointP")
    viz(marginalize(LL, function(x){return {pC: x[0]+x[1]}}))
    viz(marginalize(LL, function(x){return {pCgivenA: x[0]/(x[0]+x[2])}}))
    viz(marginalize(LL, function(x){return {pA: x[0]+x[2]}}))
    viz(marginalize(LL, function(x){return {pAgivenC: x[0]/(x[0]+x[1])}}))
    viz(marginalize(LL, function(x){return {pac: x[0]}}))
    viz(marginalize(LL, function(x){return {pnac: x[1]}}))
    viz(marginalize(LL, function(x){return {panc: x[2]}}))
    viz(marginalize(LL, function(x){return {pnanc: x[3]}}))
  }else if(query=='cn'){
    var LL = literalListener(utterance, 'bn')
    var summarized = summarizeListenerCNs(LL)
    viz(LL)
    viz(summarized)
  }else{error('only marginals supported for visualizing')}
}

var displayS = function(utterance, qud){
  qud ? display('qud is: ' + qud) : display('qud is not used')
  var LL = sample(literalListener(utterance, "bn"))
  display('speaker p: ' + LL.jointP)
  display('speaker cn: ' + LL.cn)
  viz(speaker(LL.jointP, qud))
}

var displayPL = function(pragListener){
  var marginalCN = marginalize(pragListener, function(bn){return{causalNet: bn['cn']}})
  viz(marginalCN)

  var marginal = marginalize(pragListener, function(bn){
    dependentNetsAC.includes(bn.cn) ?
      'C depends on A' :
    dependentNetsCA.includes(bn.cn) ?
      'A depends on C' :
    independentNets.includes(bn.cn) ?
      'A,C ind.' :
    biscuitNetsAC.includes(bn.cn) ?
      'A biscuits C' :
    biscuitNetsCA.includes(bn.cn) ?
      'C biscuits A' :
    perfectionNetsAC.includes(bn.cn) ?
      'A perfects C' :
    perfectionNetsCA.includes(bn.cn) ?
      'C perfects A' :
      error('unknown CausalNet: ' + bn.cn)
  })
  viz(marginal)

  var summarized = summarizeListenerCNs(pragListener)
  viz(summarized)

//   viz(marginalize(pragListener, function(bn){return {pC: pc(bn['jointP'])}}))
//   viz(marginalize(pragListener, function(bn){return {pA: pa(bn['jointP'])}}))
//   viz(marginalize(pragListener, function(bn){
//     return {pCgivenA: pCgivenA(bn['jointP'])}}))
//   viz(marginalize(pragListener, function(bn){
//     return {pAgivenC: pAgivenC(bn['jointP'])}}))
  // viz(marginalize(pragListener, function(bn){return {qud: bn['qud']}}))
}

var getEVs = function(listener, probFunc){
  var listener_avg = sum(map(function(LLtable) {
    Math.exp(listener.score(LLtable)) * probFunc(LLtable)
  }, listener.support()))
  return listener_avg
}

var evs = function(pragListener){
  return {'C|A': getEVs(pragListener, pCgivenA),
          'A|C': getEVs(pragListener, pAgivenC),
          'C|-A': getEVs(pragListener, pCgivenNA),
          'A|-C': getEVs(pragListener, pAgivenNC),
          'A': getEVs(pragListener, pa),
          'C': getEVs(pragListener, pc)}
}
//PLOTS
var utterance = "If A, C"

var causalNet = "A implies C"
var query = "jointP"
var qud = ""
// var bias = "biscuits"
var bias = ""
// var bias = "conditional"
//
// Literal listener
displayLL(utterance, 'cn')
// display('LL_avg for utterance: ' + utterance)
// display(get_LL_avg(utterance))

// Pragmatic speaker
// var p = [0.677, 0.29, 0.001, 0.032]
// var p = [0.274, 0.159, 0.019, 0.548]
// var p = [0.246, 0.321, 0.014, 0.419]
// var p = [0.048, 0.617, 0.003, 0.332]
// var p = [0.024375,0.365625,0.0006250000000000006,0.609375]
// display('Pragmatic speakers table: ' + p)
// viz(speaker(p, qud))

// displayS(utterance, qud)

// Pragmatic Listener
// display('Pragmatic Listener hears: ' + utterance)

// var pragListener = listener(utterance, qud, bias)
// display('nb distinct samples: ' + Object.keys(pragListener.getDist()).length)
// displayPL(pragListener)

// var listenerProbs = marginalize(pragListener, function(bn){return bn['jointP']})
// print(evs(listenerProbs))
// pragListener
