// SET PARAMETERS //
var speakerOptimality = 5
var threshold = 0.9

var mcmcsamples = 1000
var onlyMap = true

var nTables = 10000
var granularity = 30

var utterances = ["A", "C", "If A, C", "If C, A", "not A", "not C", "If A, not C",
                  "If not A, C", "If not A, not C", "If C, not A", "If not C, A",
                  "If not C, not A"]
// "Either both or none", ""]
display('granularity is set to: ' + granularity)
display('nb tables foreach Bayes Net: ' + nTables)
display('speaker optimality is set to ' + speakerOptimality)
// display("# mcmc samples for pragmatic listener: " + mcmcsamples)
/////////////////////////////////////////////
var roundTo3 = function(x){
  return Math.round(x*1000)/1000
  }

// for using predefined probability values from "Discrete beta"
var midBins = map(function(x) {roundTo3(x/granularity +
                                        1/(2*granularity))},
                  _.range(0,granularity))

var DiscreteBeta = cache(function(a, b, exclude){
  Infer({model: function(){
    categorical({
      vs:remove(exclude, midBins),
      ps:map(function(x){
        Math.exp(Beta({a, b}).score(x))
      }, remove(exclude, midBins))
    })
  }})
})

// for using n tables for each Bayes Net
// samples: [p(a), p(c)] 
var DiscreteUniformTuples = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    return [uniform({a:0, b: 1}), uniform({a:0, b: 1})]
    }})
})

// samples: [p(a), p(c|a), p(c|not a)]
var DiscreteBetaTriplesAC = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pcgivena =  beta({a:0.5, b: 0.5})
    return [uniform({a:0, b: 1}), pcgivena, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesCA = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pagivenc =  beta({a:0.5, b: 0.5})
    return [uniform({a:0, b: 1}), pagivenc, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesNAC = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pcgivenNa =  beta({a:0.5, b: 0.5})
    return [uniform({a:0, b: 1}), pcgivenNa, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesNCA = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pagivenNc =  beta({a:0.5, b: 0.5})
    return [uniform({a:0, b: 1}), pagivenNc, beta({a:1, b: 1})]
    }})
})

var buildTable = function(probs, bn){
  if(bn == 'A ind. C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[1],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])]
   }else if(bn=='A implies C' || bn=='not A implies C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[2],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])]
   } else if(bn == 'C implies A' || bn=='not C implies A'){
    return [probs[0]*probs[1], (1-probs[1]) * probs[0],
           probs[2]*(1-probs[0]), (1-probs[2])*(1-probs[0])]
   }else{
    error("probability table cannot be build for bn " + bn)
  }
}
// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}

var meaning = cache(function(utterance, table){
  utterance == "A" ?
    pa(table) > threshold :

  utterance == "C" ?
    pc(table) > threshold :

  utterance == "If A, C" ?
    table[0] > pa(table) * threshold :

  utterance == "If C, A" ?
    table[0] > pc(table) * threshold :

  utterance == "not A" ?
    pna(table) > threshold :

  utterance == "not C" ?
    pnc(table) > threshold :

  utterance == "If A, not C" ?
    table[2] > pa(table) * threshold :

  utterance == "If not A, C" ?
    table[1] > pna(table) * threshold :

  utterance == "If not A, not C" ?
    table[3] > pna(table) * threshold :

  utterance == "If C, not A" ?
    table[1] > pc(table) * threshold :

  utterance == "If not C, A" ?
    table[2] > pnc(table) * threshold :

  utterance == "If not C, not A" ?
      table[3] > pnc(table) * threshold :

  utterance == "Either both or none" ?
    table[0]+table[3] > threshold :
  
  utterance == "" ?
    true :
  -1
})

//PRIORS
var networkPrior = function() {
  var net = uniformDraw(["A implies C",
                         "C implies A",
                         "A ind. C", 
                         "not A implies C", 
                         "not C implies A"])
  return net
 }

var probsPriorNtables = function(network){
   if(network == 'A ind. C'){
     return sample(DiscreteUniformTuples(nTables))
   }else if(network == 'A implies C'){
     return sample(DiscreteBetaTriplesAC(nTables))
   }else if(network == 'C implies A'){
     return sample(DiscreteBetaTriplesCA(nTables))
   }else if(network == 'not C implies A'){
     return sample(DiscreteBetaTriplesNCA(nTables))
   }else if(network == 'not A implies C'){
     return sample(DiscreteBetaTriplesNAC(nTables))
   }
   else{error("unknown network: "+network)}
 }

var probsPrior = function(network){
  // [p(a), p(c)] or [p(a), p(c|a), p(c|not a)]
  if(network != 'A ind. C'){
    var pcond =  sample(DiscreteBeta(.5,.5,''))
    return [sample(DiscreteBeta(1,1,'')), pcond, sample(DiscreteBeta(1,1,pcond))]
  } else{
     return [sample(DiscreteBeta(1,1,'')), sample(DiscreteBeta(1,1,''))]
  }
}
var statePrior = cache(function(){
  return Infer({method:'enumerate', model:function(){
    var network = networkPrior();
    var probs = probsPrior(network);
    // var probs = probsPriorNtables(network)
    var table = buildTable(probs, network)
    return {'BN': network, 'jointP': table}
  }
  })
})

// MODEL
var literalListener = cache(function(utterance, query, causalNet){
  Infer({method:'enumerate',model: function(){
    var state = sample(statePrior())
    condition(meaning(utterance, state['jointP']))
//     condition(state['BN']==causalNet)
    if(query == 'BN'){return state['BN']}
    else{return state['jointP']}
  }})
})

var displayLL = function(utterance, query){
  display('Literal Listener hears: ' + utterance)
  if(query=='jointP'){  
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pC: x[0]+x[1]}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pCgivenA: x[0]/(x[0]+x[2])}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pA: x[0]+x[2]}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pAgivenC: x[0]/(x[0]+x[1])}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pac: x[0]}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pnac: x[1]}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {panc: x[2]}}))
    viz(marginalize(literalListener(utterance, goal), function(x)
                    {return {pnanc: x[3]}}))

  }else if(query=='BN'){
    viz(marginalize(literalListener(utterance, goal), function(x){return {BN: x}}))
  }
  else{error('unknown query' + query)}
}

var KL = cache(function(speakerProbs, listenerProbs){
  sum(map(function(cell) {
    if(speakerProbs[cell] == 0 || listenerProbs[cell]==0){
      return 0
    }else{
      return speakerProbs[cell] * Math.log(speakerProbs[cell] / listenerProbs[cell])
    }}, _.range(speakerProbs.length)))
})

var get_LL_avg = cache(function(utterance, causalNet) {
  var LL = literalListener(utterance, 'jointP', causalNet)
  var LL_avg = map(function(cell){ sum(map(function(LLtable) {
    Math.exp(LL.score(LLtable)) * LLtable[cell]
  }, 
                   LL.support()))}, _.range(4))
  return(LL_avg)
})

//print(get_LL_avg("If C, not A", "A implies C"))
//print(get_LL_avg("If A, C", "C implies A"))
// print(get_LL_avg("A and C", "C implies A"))
// print(get_LL_avg("A and C", "A implies C"))

var get_EU_avg = function(utterance, causalNet, state) {
  var LL_avg = get_LL_avg(utterance, causalNet)
  return(-KL(state, LL_avg))
}

var speaker = cache(function(state, speakerGoals){
  return Infer({method:'enumerate', model: function(){  
    var utterance = uniformDraw(utterances)
    
    var LLbn = speakerGoals.bn != 0 ? 
        literalListener(utterance, 'BN', state['BN']) : false
    
    var utilityP = speakerGoals.p != 0 ? 
        speakerGoals.p * get_EU_avg(utterance, state['BN'], state['jointP']) : 0
    
    var utilityBN = LLbn ?  speakerGoals.bn * LLbn.score(state['BN']) : 0

    factor(speakerOptimality*(utilityP + utilityBN))
    return utterance
  }
 })
})

var listener = function(utterance, speakerGoals){
//     Infer({method:'MCMC', samples:mcmcsamples, lag:1, burn:100,
//            callbacks: [editor.MCMCProgress()], model: function(){
//     Infer({method:'enumerate', model: function(){
  return Infer({method:'rejection',samples:2000, model:function(){
    var state = sample(statePrior());
    observe(speaker(state,speakerGoals),utterance)
    return state
  }})
}

var displayListener = function(utterance, speakerGoals){
  display('speaker optimality is set to ' + speakerOptimality)
  display('speaker transmits probs: ' + speakerGoals.p)
  display('speaker transmits bn: ' + speakerGoals.bn)

  display('Pragmatic Listener hears: ' + utterance)
  var pragListener = listener(utterance, speakerGoals)

  viz(marginalize(pragListener, function(state){return {BN: state['BN']}}))
  viz(marginalize(pragListener, function(state){return {pC: pc(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){return {pA: pa(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){return {pCgivenA: pCgivenA(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){return {pAgivenC: pAgivenC(state['jointP'])}}))

}

//PLOTS
var speakerGoals = {bn:0, p:1}
// var speakerGoal = 'mix'
var utterance = "If A, C"
// displayLL("If A, C", speakerGoal)
displayListener(utterance, speakerGoals)

// var p = [0.677, 0.29, 0.001, 0.032]
// var p = [0.274, 0.159, 0.019, 0.548]
// var p = [0.246, 0.321, 0.014, 0.419]
// var p = [0.048, 0.617, 0.003, 0.332]

// display(p)
// viz(speaker({'BN':'', 'jointP': p}, {bn:0, p:1}))
