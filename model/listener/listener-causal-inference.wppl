// SET PARAMETERS //
var speakerOptimality = 5
var threshold = 0.9
var threshold_likely = 0.6

var nsamples = 3000

var nTables = 7000
var granularity = 20

var utterances = ["A", "C", "If A, C", "If C, A", "not A", "not C", "If A, not C",
                  "If not A, C", "If not A, not C", "If C, not A", "If not C, A",
                  "If not C, not A",
                  "A and C", "A exor C",
                  "likely A", "likely C"]
//                   "Either both or none", "neither A nor C"]

display('granularity is set to: ' + granularity)
display('nb tables foreach Bayes Net: ' + nTables)
display('speaker optimality is set to ' + speakerOptimality)
display("# samples for pragmatic listener: " + nsamples)
display('----------------------------------------')
/////////////////////////////////////////////
var roundTo3 = function(x){
  return Math.round(x*1000)/1000
  }

// for using predefined probability values from "Discrete beta"
var midBins = map(function(x) {roundTo3(x/granularity +
                                        1/(2*granularity))},
                  _.range(0,granularity))

var DiscreteBeta = cache(function(a, b, exclude){
  Infer({model: function(){
    categorical({
      vs:remove(exclude, midBins),
      ps:map(function(x){
        Math.exp(Beta({a, b}).score(x))
      }, remove(exclude, midBins))
    })
  }})
})

// for using n tables for each Bayes Net
// samples: [p(a), p(c)] 
var DiscreteUniformTuples = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    return [uniform({a:0, b: 1}), uniform({a:0, b: 1})]
    }})
})

// samples: [p(a), p(c|a), p(c|not a)]
var DiscreteBetaTriplesAC = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pcgivena =  beta({a:10, b: 1})
    return [uniform({a:0, b: 1}), pcgivena, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesCA = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pagivenc =  beta({a:10, b: 1})
    return [uniform({a:0, b: 1}), pagivenc, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesNAC = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pcgivenNa =  beta({a:10, b: 1})
    return [uniform({a:0, b: 1}), pcgivenNa, beta({a:1, b: 1})]
    }})
})

var DiscreteBetaTriplesNCA = mem(function(n) {
  Infer({method:'forward', samples: n, model:function(){
    var pagivenNc =  beta({a:10, b: 1})
    return [uniform({a:0, b: 1}), pagivenNc, beta({a:1, b: 1})]
    }})
})

var buildTable = function(probs, bn){
  if(bn == 'A ind. C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[1],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[1])]
   }
  else if(bn=='A implies C'){
    return [probs[0]*probs[1], (1-probs[0])*probs[2],
            probs[0]*(1-probs[1]), (1-probs[0])*(1-probs[2])]
   }
  else if(bn == 'C implies A'){
    return [probs[0]*probs[1], (1-probs[1]) * probs[0],
           probs[2]*(1-probs[0]), (1-probs[2])*(1-probs[0])]
   }
  else if(bn=='not A implies C'){
     return [(1-probs[0])*probs[2], probs[1] * probs[0],
           (1-probs[0])*(1-probs[2]), (1-probs[1])*probs[0]]
   }
  else if (bn=='not C implies A'){
    return [(1-probs[0])*probs[2], (1-probs[2]) * (1-probs[0]),
           probs[1]*probs[0], (1-probs[1])*probs[0]]        
   }
  else{
    error("probability table cannot be build for bn " + bn)
  }
}
// marginal probabilities
var pa = function(x){return x[0]+x[2]}
var pc = function(x){return x[0]+x[1]}
var pna = function(x){return x[1]+x[3]}
var pnc = function(x){return x[2]+x[3]}
// conditional probabilities
var pAgivenC = function(x){return x[0]/pc(x)}
var pAgivenNC = function(x){return x[2]/pnc(x)}
var pNAgivenC = function(x){return x[1]/pc(x)}
var pNAgivenNC = function(x){return x[3]/pnc(x)}
var pCgivenA = function(x){return x[0]/pa(x)}

var meaning = cache(function(utterance, table){
  utterance == "A" ?
    pa(table) >= threshold :

  utterance == "C" ?
    pc(table) >= threshold :

  utterance == "If A, C" ?
    table[0] >= pa(table) * threshold :

  utterance == "If C, A" ?
    table[0] >= pc(table) * threshold :

  utterance == "not A" ?
    pna(table) >= threshold :

  utterance == "not C" ?
    pnc(table) >= threshold :

  utterance == "If A, not C" ?
    table[2] >= pa(table) * threshold :

  utterance == "If not A, C" ?
    table[1] >= pna(table) * threshold :

  utterance == "If not A, not C" ?
    table[3] >= pna(table) * threshold :

  utterance == "If C, not A" ?
    table[1] >= pc(table) * threshold :

  utterance == "If not C, A" ?
    table[2] >= pnc(table) * threshold :

  utterance == "If not C, not A" ?
      table[3] >= pnc(table) * threshold :

  utterance == "Either both or none" ?
    table[0]+table[3] >= threshold :
  
  utterance == "likely A" ? 
    table[0] + table[2] >= threshold_likely :
  
  utterance == "likely C" ?
    table[0] + table[1] >= threshold_likely : 
  
  utterance == "A exor C" ?
    table[1] + table[2] >= threshold :
  
  utterance == "A and C" ?
    table[0] >= threshold :
  
  utterance == "neither A nor C" ?
    table[3] >= threshold :
  
  utterance == "" ?
    true :
  -1
})

//PRIORS
var networkPrior = function() {
  var net = uniformDraw(["A implies C",
                         "C implies A",
                         "A ind. C"])
			//"not A implies C",
			//"not C implies A"])
  return net
 }

var probsPriorNtables = function(network){
   if(network == 'A ind. C'){
     return sample(DiscreteUniformTuples(nTables))
   }else if(network == 'A implies C'){
     return sample(DiscreteBetaTriplesAC(nTables))
   }else if(network == 'C implies A'){
     return sample(DiscreteBetaTriplesCA(nTables))
   }else if(network == 'not C implies A'){
     return sample(DiscreteBetaTriplesNCA(nTables))
   }else if(network == 'not A implies C'){
     return sample(DiscreteBetaTriplesNAC(nTables))
   }
   else{error("unknown network: "+network)}
 }

var probsPrior = function(network){
  // [p(a), p(c)] or [p(a), p(c|a), p(c|not a)]
  if(network != 'A ind. C'){
//     var pcond =  sample(DiscreteBeta(10, 1,''))
var pcond = sample(DiscreteBeta(0.5,0.5,''))
    return [sample(DiscreteBeta(1,1,'')), pcond, sample(DiscreteBeta(1,1,pcond))]
  }else{
     return [sample(DiscreteBeta(1,1,'')), sample(DiscreteBeta(1,1,''))]
  }
}
var statePrior = cache(function(){
  return Infer({method:'enumerate', model:function(){
    var network = networkPrior();
     var probs = probsPrior(network);
//    var probs = probsPriorNtables(network)
    var table = buildTable(probs, network)
    return {'BN': network, 'jointP': table}
  }
  })
})

// MODEL
var literalListener = cache(function(utterance, query, causalNet){
  Infer({method:'enumerate',model: function(){
    var state = sample(statePrior())
    condition(meaning(utterance, state['jointP']))
//     condition(state['BN']==causalNet)
    if(query == 'BN'){return state['BN']}
    else{return state['jointP']}
  }})
})

var KL = cache(function(speakerProbs, listenerProbs){
  sum(map(function(cell) {
    if(speakerProbs[cell] == 0 || listenerProbs[cell]==0){
      return 0
    }else{
      return speakerProbs[cell] * Math.log(speakerProbs[cell] / listenerProbs[cell])
    }}, _.range(speakerProbs.length)))
})

var get_LL_avg = cache(function(utterance, causalNet) {
  var LL = literalListener(utterance, 'jointP', causalNet)
  var LL_avg = map(function(cell){ sum(map(function(LLtable) {
    Math.exp(LL.score(LLtable)) * LLtable[cell]
  }, 
                   LL.support()))}, _.range(4))
  return(LL_avg)
})

var get_EU_avg = function(utterance, causalNet, state) {
  var LL_avg = get_LL_avg(utterance, causalNet)
  return(-KL(state, LL_avg))
}

var speaker = cache(function(state, speakerGoals){
  return Infer({method:'enumerate', model: function(){  
    var utterance = uniformDraw(utterances)
    
    var LLbn = speakerGoals.bn != 0 ? 
        literalListener(utterance, 'BN', state['BN']) : false
    
    var utilityP = speakerGoals.p != 0 ? 
        speakerGoals.p * get_EU_avg(utterance, state['BN'], state['jointP']) : 0
    
    var utilityBN = LLbn ?  speakerGoals.bn * LLbn.score(state['BN']) : 0

    factor(speakerOptimality*(utilityP + utilityBN))
    return utterance
  }
 })
})

var listener = function(utterance, speakerGoals){
//     Infer({method:'MCMC', samples:nsamples, lag:1, burn:100,
//            callbacks: [editor.MCMCProgress()], model: function(){
//     Infer({method:'enumerate', model: function(){
//   return Infer({method:'MCMC', samples:nsamples, lag:1, burn:100,
//                 callbacks: [editor.MCMCProgress()], 
//                   kernel: { HMC: { stepSize: 0.1, steps: 10 } }, model:function(){  
  return Infer({method:'rejection',samples:nsamples, model:function(){
  	var state = sample(statePrior());
    	observe(speaker(state,speakerGoals),utterance)
    	return state
	}
})}

var displayLL = function(utterance, query, causalNet){
  display('Literal Listener hears: ' + utterance)
  if(query=='jointP'){
    var LL = literalListener(utterance, "jointP", causalNet)
    viz(marginalize(LL, function(x){return {pC: x[0]+x[1]}}))
    viz(marginalize(LL, function(x){return {pCgivenA: x[0]/(x[0]+x[2])}}))
    viz(marginalize(LL, function(x){return {pA: x[0]+x[2]}}))
    viz(marginalize(LL, function(x){return {pAgivenC: x[0]/(x[0]+x[1])}}))
    viz(marginalize(LL, function(x){return {pac: x[0]}}))
    viz(marginalize(LL, function(x){return {pnac: x[1]}}))
    viz(marginalize(LL, function(x){return {panc: x[2]}}))
    viz(marginalize(LL, function(x){return {pnanc: x[3]}}))
  }else{
    var LL = literalListener(utterance, 'BN', causalNet)
    viz(LL)
  }
}

var displayS = function(utterance, causalNet, speakerGoals){
  print('LL_avg for utterance: ' + utterance + ': ')
  print(get_LL_avg(utterance, causalNet))
  var LLp = sample(literalListener(utterance, "jointP", causalNet))
  print('speaker p: ' + LLp)
  viz(speaker({BN:causalNet, jointP:LLp}, speakerGoals))
}
var displayPL = function(pragListener){
  viz(marginalize(pragListener, function(state){return {BN: state['BN']}}))
  viz(marginalize(pragListener, function(state){return {pC: pc(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){return {pA: pa(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){
    return {pCgivenA: pCgivenA(state['jointP'])}}))
  viz(marginalize(pragListener, function(state){
    return {pAgivenC: pAgivenC(state['jointP'])}}))
}

//PLOTS
var utterance = "If A, C"
var speakerGoals = {bn:0, p:1}
var bn = "A implies C"
var query = 'jointP'
// Literal listener
//displayLL(utterance, "BN", bn)

// Pragmatic speaker
// var p = [0.677, 0.29, 0.001, 0.032]
// var p = [0.274, 0.159, 0.019, 0.548]
// var p = [0.246, 0.321, 0.014, 0.419]
// var p = [0.048, 0.617, 0.003, 0.332]
// display('Pragmatic speakers table: ' + p)
// viz(speaker({'BN':bn, 'jointP': p}, speakerGoals))

// displayS(utterance, bn, speakerGoals)

// Pragmatic Listener
display('Pragmatic Listener hears: ' + utterance)
display('speaker transmits probs: ' + speakerGoals.p)
display('speaker transmits bn: ' + speakerGoals.bn)
  
var pragListener = listener(utterance, speakerGoals)
print('nb distinct samples: ' + Object.keys(pragListener.getDist()).length)
displayPL(pragListener)

